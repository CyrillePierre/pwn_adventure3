#include <cstdio>
#include <tuple>
#include <utility>
#include <dlfcn.h>

#include "gamelogic/player.h"

#ifndef HACK_PATH
#define HACK_PATH ""
#endif

/* *** */

namespace shared {

void (*chat)(char const*);

char const* (*teamName)();
char const* (*playerName)();

bool (*canJump)();

float (*walkingSpeed)();
float (*jumpSpeed)();
float (*sprintMultiplier)();

}

/* *** */

namespace impl {

static void (*chat)(char const*);
static char const* (*teamName)();
static char const* (*playerName)();
static bool (*canJump)();
static float (*walkingSpeed)();
static float (*sprintMultiplier)();
static float (*jumpSpeed)();

}

void Player::Chat(char const*s) {
	void reload();
	if(!*s) reload();
	return impl::chat(s);
}

char const* Player::GetTeamName() { return impl::teamName(); }
char const* Player::GetPlayerName() { return impl::playerName(); }
bool Player::CanJump() { return impl::canJump(); }
float Player::GetWalkingSpeed() { return impl::walkingSpeed(); }
float Player::GetSprintMultiplier() { return impl::sprintMultiplier(); }
float Player::GetJumpSpeed() { return impl::jumpSpeed(); }

/* *** */

#define FN(V, SYM) std::make_tuple(std::ref(impl::V), std::ref(shared::V), #V, SYM)
static auto redefs = std::make_tuple(
	FN(chat,              "_ZN6Player4ChatEPKc"),
	FN(playerName,        "_ZN6Player13GetPlayerNameEv"),
	FN(teamName,          "_ZN7GameAPI11GetTeamNameEv"),
	FN(canJump,           "_ZN6Player7CanJumpEv"),
	FN(walkingSpeed,      "_ZN6Player15GetWalkingSpeedEv"),
	FN(jumpSpeed,         "_ZN6Player12GetJumpSpeedEv"),
	FN(sprintMultiplier,  "_ZN6Player19GetSprintMultiplierEv")
);

static constexpr std::size_t redefsSize = std::tuple_size<decltype(redefs)>::value;


template<typename F>
F &load(F &f, char const*name, void *handle = RTLD_NEXT) {
	void * v = dlsym(handle, name);
	if(v) f = reinterpret_cast<F>(v);
	else std::fprintf(stderr, "[!] failed to load '%s'\n", name);
	return f;
}

template <class T>
static void reloadFn(void * handle, T & t) {
	load(std::get<0>(t), std::get<2>(t), handle);
}

template <class Tuple, std::size_t... Is>
static void reloadTuple(void* handle, Tuple const & tuple, std::index_sequence<Is...>) {
	using Expander = int[];
	Expander{(reloadFn(handle, std::get<Is>(tuple)), 0)...};
}

void reload() {
	static void* handle = nullptr;
	std::printf("reloading from '%s'... ", HACK_PATH);

	if(handle) dlclose(handle);
	handle = dlopen(HACK_PATH, RTLD_LAZY);

	reloadTuple(handle, redefs, std::make_index_sequence<redefsSize>{});
	std::puts("done");
}

template <class T>
static void loadFn(T & t) {
	std::get<0>(t) = load(std::get<1>(t), std::get<3>(t));
}

template <class Tuple, std::size_t... Is>
void loadTuple(Tuple & tuple, std::index_sequence<Is...>) {
	using Expander = int[];
	Expander{(loadFn(std::get<Is>(tuple)), 0)...};
}

static bool loaded = []{
	loadTuple(redefs, std::make_index_sequence<redefsSize>{});
	std::puts("[hack] loaded");
	return true;
}();
