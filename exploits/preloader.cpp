#include <cstdio>
#include <tuple>
#include <utility>
#include <dlfcn.h>

#include "gamelogic/player.h"

#ifndef HACK_PATH
#define HACK_PATH ""
#endif

/* *** */

namespace shared {

void (*chat)(char const*);
char const* (*teamName)();
char const* (*playerName)();
bool (*canJump)();
float (*walkingSpeed)();
float (*jumpSpeed)();
float (*sprintMultiplier)();

}

#define FN(V, SYM) std::make_tuple(decltype(shared::V){}, std::ref(shared::V), #V, SYM)
static auto redefs = std::make_tuple(
	FN(chat,              "_ZN6Player4ChatEPKc"),
	FN(playerName,        "_ZN6Player13GetPlayerNameEv"),
	FN(teamName,          "_ZN7GameAPI11GetTeamNameEv"),
	FN(canJump,           "_ZN6Player7CanJumpEv"),
	FN(walkingSpeed,      "_ZN6Player15GetWalkingSpeedEv"),
	FN(jumpSpeed,         "_ZN6Player12GetJumpSpeedEv"),
	FN(sprintMultiplier,  "_ZN6Player19GetSprintMultiplierEv")
);

template <std::size_t I>
decltype(auto) impl = std::get<0>(std::get<I>(redefs));

void Player::Chat(char const*s) {
	void reload();
	if(!*s) reload();
	return impl<0>(s);
}

char const* Player::GetTeamName()   { return impl<1>(); }
char const* Player::GetPlayerName() { return impl<2>(); }
bool Player::CanJump()              { return impl<3>(); }
float Player::GetWalkingSpeed()     { return impl<4>(); }
float Player::GetJumpSpeed()        { return impl<5>(); }
float Player::GetSprintMultiplier() { return impl<6>(); }

/* *** */

static constexpr std::size_t redefsSize = std::tuple_size<decltype(redefs)>::value;

template<typename F>
F &load(F &f, char const*name, void *handle = RTLD_NEXT) {
	void * v = dlsym(handle, name);
	if(v) f = reinterpret_cast<F>(v);
	else std::fprintf(stderr, "[!] failed to load '%s'\n", name);
	return f;
}

template <class T>
static void reloadFn(void * handle, T & t) {
	load(std::get<0>(t), std::get<2>(t), handle);
}

template <class Tuple, std::size_t... Is>
static void reloadTuple(void* handle, Tuple & tuple, std::index_sequence<Is...>) {
	using Expander = int[];
	Expander{(reloadFn(handle, std::get<Is>(tuple)), 0)...};
}

void reload() {
	static void* handle = nullptr;
	std::printf("reloading from '%s'... ", HACK_PATH);

	if(handle) dlclose(handle);
	handle = dlopen(HACK_PATH, RTLD_LAZY);

	reloadTuple(handle, redefs, std::make_index_sequence<redefsSize>{});
	std::puts("done");
}

template <class T>
static void loadFn(T & t) {
	std::get<0>(t) = load(std::get<1>(t), std::get<3>(t));
}

template <class Tuple, std::size_t... Is>
static void loadTuple(Tuple & tuple, std::index_sequence<Is...>) {
	using Expander = int[];
	Expander{(loadFn(std::get<Is>(tuple)), 0)...};
}

static bool loaded = []{
	loadTuple(redefs, std::make_index_sequence<redefsSize>{});
	std::puts("[hack] loaded");
	return true;
}();
