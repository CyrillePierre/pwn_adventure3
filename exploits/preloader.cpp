#include <cstdio>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <tuple>
#include <utility>
#include <dlfcn.h>

#define PRELOADER_CPP
#include "gamelogic/player.h"
#include "preloader.h"

#ifndef HACK_PATH
#define HACK_PATH ""
#endif

uint8_t * keyMap;

#define FN(V, SYM) std::make_tuple(decltype(shared::V){}, std::ref(shared::V), #V, SYM)
static auto redefs = std::make_tuple(
	FN(chat,              "_ZN6Player4ChatEPKc"),
	FN(playerName,        "_ZN6Player13GetPlayerNameEv"),
	FN(teamName,          "_ZN7GameAPI11GetTeamNameEv"),
	FN(canJump,           "_ZN6Player7CanJumpEv"),
	FN(walkingSpeed,      "_ZN6Player15GetWalkingSpeedEv"),
	FN(jumpSpeed,         "_ZN6Player12GetJumpSpeedEv"),
	FN(sprintMultiplier,  "_ZN6Player19GetSprintMultiplierEv"),
	FN(setSprintState,    "_ZN6Player14SetSprintStateEb"),
	FN(setJumpState,      "_ZN6Player12SetJumpStateEb"),
	FN(isOnGround,        "_ZN5Actor10IsOnGroundEv")
);

template <std::size_t I>
decltype(auto) impl = std::get<0>(std::get<I>(redefs));

void Player::Chat(char const*s) {
	void reload();
	if(!*s) reload();
	return impl<0>(this, s);
}

char const* Player::GetTeamName()   { return impl<1>(this); }
char const* Player::GetPlayerName() { return impl<2>(this); }
bool Player::CanJump()              { return impl<3>(this); }
float Player::GetWalkingSpeed()     { return impl<4>(this); }
float Player::GetJumpSpeed()        { return impl<5>(this); }
float Player::GetSprintMultiplier() { return impl<6>(this); }
void Player::SetSprintState(bool b) { return impl<7>(this, b); }
void Player::SetJumpState(bool b)   { return impl<8>(this, b); }
bool Actor::IsOnGround()            { return impl<9>(this); }

/* *** */

static constexpr std::size_t redefsSize = std::tuple_size<decltype(redefs)>::value;

template<typename F>
F &load(F &f, char const*name, void *handle = RTLD_NEXT) {
	void * v = dlsym(handle, name);
	if(v) f = reinterpret_cast<F>(v);
	else std::fprintf(stderr, "[!] failed to load '%s'\n", name);
	return f;
}

template <class T>
static void reloadFn(void * handle, T & t) {
	load(std::get<0>(t), std::get<2>(t), handle);
}

template <class Tuple, std::size_t... Is>
static void reloadTuple(void* handle, Tuple & tuple, std::index_sequence<Is...>) {
	using Expander = int[];
	Expander{(reloadFn(handle, std::get<Is>(tuple)), 0)...};
}

void reload() {
	static void* handle = nullptr;
	std::printf("reloading from '%s'... ", HACK_PATH);

	if(handle) dlclose(handle);
	handle = dlopen(HACK_PATH, RTLD_LAZY);

	reloadTuple(handle, redefs, std::make_index_sequence<redefsSize>{});
	std::puts("done");
}

template <class T>
static void loadFn(T & t) {
	std::get<0>(t) = load(std::get<1>(t), std::get<3>(t));
}

template <class Tuple, std::size_t... Is>
static void loadTuple(Tuple & tuple, std::index_sequence<Is...>) {
	using Expander = int[];
	Expander{(loadFn(std::get<Is>(tuple)), 0)...};
}

bool keyState(uint8_t id) {
	return keyMap[id];
}

static bool loaded = []{
	loadTuple(redefs, std::make_index_sequence<redefsSize>{});
	std::puts("[hack] loaded");

	bool shm_loaded = true;
	int memid = shmget(0x1337, 256, 0);
	if(memid == -1) perror("shmget"), shm_loaded = false;
	keyMap = (uint8_t*) shmat(memid, nullptr, 0);
	if(keyMap == (void*)-1) perror("shmat"), shm_loaded = false;
	if(!shm_loaded) keyMap = (uint8_t*) calloc(256, 1);
	
	return true;
}();
